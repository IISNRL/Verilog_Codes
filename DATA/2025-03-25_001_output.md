# RISC-V Core with Branch Prediction Report

## 1. Task Description

**Aim:** This project aims to design a simplified, single-cycle RISC-V core with a basic branch predictor. The core will execute a subset of RISC-V instructions and utilize a 2-bit saturating counter to predict branch outcomes.

**Overview:** The digital hardware component is a RISC-V processor core. It fetches instructions from memory, decodes them, executes them, and writes results back to registers or memory. The branch predictor attempts to guess the outcome of branch instructions before they are actually executed, allowing the processor to continue fetching and decoding instructions speculatively.  If the prediction is correct, the speculative execution proceeds without interruption. If the prediction is incorrect, the pipeline must be stalled to correct the speculative execution, introducing a performance penalty.

**Significance:** Branch prediction is crucial for improving processor performance. Without it, the processor would have to wait for the branch instruction to complete before fetching the next instruction, leading to significant pipeline stalls.  A simple 2-bit saturating counter is a foundational branch prediction technique, demonstrating the core principles of speculative execution and hazard handling.

## 2. Verilog Codes

```verilog
module riscv_core (
  input clk,
  input rst,
  output reg [31:0] pc,
  output reg [31:0] instruction,
  output reg [31:0] alu_result,
  output reg [31:0] write_data,
  output reg write_enable,
  output reg [4:0] write_reg
);

  // Parameters
  localparam IDLE = 2'b00;
  localparam FETCH = 2'b01;
  localparam DECODE = 2'b10;
  localparam EXECUTE = 2'b11;

  // Internal Signals
  reg [1:0] state;
  reg [31:0] fetched_instruction;
  reg [31:0] decoded_instruction;
  reg [31:0] rs1_data;
  reg [31:0] rs2_data;
  reg [31:0] immediate;
  reg [4:0] rs1_reg;
  reg [4:0] rs2_reg;
  reg [4:0] rd_reg;
  reg alu_op;
  reg mem_read;
  reg mem_write;
  reg reg_write;

  // Branch Predictor
  reg [1:0] branch_prediction;
  localparam PREDICT_NOT_TAKEN = 2'b00;
  localparam PREDICT_TAKEN = 2'b01;

  // Instruction Subset: R-type, I-type, S-type, J-type (limited)
  // R-type: add, sub, sll, slt
  // I-type: addi, slli, slti
  // S-type: sw
  // J-type: jal (limited)

  // Data Memory (Simplified)
  reg [31:0] data_memory [0:1023];

  always @(posedge clk) begin
    if (rst) begin
      pc <= 32'h00000000;
      branch_prediction <= PREDICT_NOT_TAKEN;
      state <= FETCH;
    end else begin
      case (state)
        FETCH: begin
          instruction <= fetched_instruction;
          pc <= pc + 4;
          state <= DECODE;
        end
        DECODE: begin
          // Simplified Instruction Decoding
          case (instruction[6:0])
            6'b000000: // R-type (add)
              rs1_reg <= instruction[19:15];
              rs2_reg <= instruction[24:20];
              rd_reg <= instruction[11:7];
              alu_op <= 0; // Add
              reg_write <= 1;
            6'b000010: // I-type (addi)
              rs1_reg <= instruction[19:15];
              rd_reg <= instruction[11:7];
              immediate <= instruction[31:25];
              alu_op <= 0; // Add
              reg_write <= 1;
            6'b000100: // S-type (sw)
              rs1_reg <= instruction[19:15];
              rd_reg <= instruction[24:20];
              immediate <= instruction[31:25];
              mem_write <= 1;
              reg_write <= 0;
            6'b011011: // J-type (jal) - limited
              rd_reg <= instruction[11:7];
              immediate <= instruction[31:25];
              reg_write <= 1;
            default: begin
              // Unknown instruction
              reg_write <= 0;
            end
          endcase
          state <= EXECUTE;
        end
        EXECUTE: begin
          // Data Fetch
          if (mem_read) begin
            // Simplified memory read
            // rs1_data <= data_memory[rs1_data];
          end

          // ALU Operation
          case (alu_op)
            0: // Add
              alu_result <= rs1_data + immediate;
            default:
              alu_result <= 0;
          endcase

          // Branch Prediction
          if (instruction[6:0] == 6'b110001) begin // beq
            if (rs1_data == rs2_data) begin
              // Branch Taken
              if (branch_prediction == PREDICT_TAKEN) begin
                // Correct Prediction
                pc <= pc + immediate;
              end else begin
                // Misprediction - Stall
                // Stall logic would be implemented here
                pc <= pc;
              end
            end else begin
              // Branch Not Taken
              if (branch_prediction == PREDICT_NOT_TAKEN) begin
                // Correct Prediction
                pc <= pc + 4;
              end else begin
                // Misprediction - Stall
                // Stall logic would be implemented here
                pc <= pc;
              end
            end
          end

          state <= FETCH;
        end
      endcase
    end
  end
endmodule
```

**Explanation:**

1.  **Instruction Subset:** The code implements a limited instruction set including R-type (add), I-type (addi), S-type (sw), and J-type (jal) instructions.
2.  **State Machine:** The design uses a state machine with three states: `FETCH`, `DECODE`, and `EXECUTE`.
3.  **Branch Prediction:**
    *   A simple branch predictor is implemented using a 2-bit register `branch_prediction`.
    *   Initially, the predictor predicts "not taken."
    *   The predictor would need to be updated based on the actual branch outcome (taken or not taken) to improve accuracy.  This update logic is missing in this simplified example.
4.  **Data Memory:** A simplified data memory is included.
5.  **Stalling:**  The code includes comments indicating where stalling logic would be implemented in case of a misprediction.  This is crucial for correct execution.
6.  **Simplified Decoding:** The instruction decoding is simplified for clarity.  A real processor would have a more complex decoding process.

**Key Improvements and Considerations:**

*   **Branch Prediction Update:** The most important missing piece is the logic to update the `branch_prediction` register based on the actual branch outcome.  This is essential for the predictor to learn and improve its accuracy.
*   **Stalling Logic:**  The stalling logic needs to be implemented to handle mispredictions.  This would involve pausing the pipeline and re-fetching the correct instruction.
*   **More Instructions:**  The instruction set can be expanded to include more instructions.
*   **Register File:** A register file would be needed to store the values of the registers.
*   **Data Hazards:**  Data hazards (when an instruction depends on the result of a previous instruction that hasn't finished yet) need to be handled.
*   **Control Hazards:** Control hazards (caused by branch instructions) need to be handled.
*   **More Realistic Memory Model:** The memory model can be made more realistic by adding address decoding and data transfer logic.
*   **Pipeline Stages:**  The design can be divided into more pipeline stages to improve performance.

This improved explanation and code provide a more complete understanding of the design and highlight the areas that need further development to create a more realistic processor.  Remember that this is a simplified example, and a real processor would be much more complex.